# OS chapter6 实验报告

***2017011998 冯卓尔 计86***

---

### 编程内容

-  新建MailBox类，仿照Pipe类的方式实现了文件标准的read和write操作，设计为一个256长度报文、16数量的信箱，是一个循环队列，结构如同PipeRingBuffer
- 信箱进程绑定：由于框架原因，用比较丑陋的方法，即在调用进程信箱的时候才进行信箱绑定，使用BTreeMap维护映射关系
- 信箱清理：在僵尸进程清理的时候，会清空相应pid的信箱内容。

## 问答作业

1. 举出使用 pipe 的一个实际应用的例子。

   我经常用的命令：

   ```
   ps -ef | grep python
   ```

   用来查看服务器上名为python数量进程的编号和状态。

2. 假设我们的邮箱现在有了更加强大的功能，容量大幅增加而且记录邮件来源，可以实现“回信”。考虑一个多核场景，有 m 个核为消费者，n 个为生产者，消费者通过邮箱向生产者提出订单，生产者通过邮箱回信给出产品。

> - 假设你的邮箱实现没有使用锁等机制进行保护，在多核情景下可能会发生哪些问题？单核一定不会发生问题吗？为什么？
> - 请结合你在课堂上学到的内容，描述读者写者问题的经典解决方案，必要时提供伪代码。
> - 由于读写是基于报文的，不是随机读写，你有什么点子来优化邮箱的实现吗？

**2-1** 

如果没有锁，可能出现临界区数据被多个生产者同时写，或者是多个消费者读到同一个邮件而产生冗余回复；

单核也不安全：因为时间中断的缘故，相邻的两个进程对同一个邮件进行读写操作，没有锁就会导致临界区还没处理完，就被下一个进程处理，这显然不是软件程序员的本意。

**2-2**

1. 使用互斥锁，在进程进入临界区之前 lock，出临界区之后unlock，希望进入临界区的进程竞争锁；
2. 维护访问队列，保证上一个进程退出后才进行下一个进程的访问

**2-3**


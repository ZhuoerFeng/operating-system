# OS chapter5 实验报告

***2017011998 冯卓尔 计86***

---

## 编程内容

- 移植代码
- `mmap`和`unmap`两个函数在新的进程空间下的调整，具体表现为申请检查的时候可以直接对着当前进程检查了，便利不少
- 在原先fork和exec的基础上，将exec的task通过fork函数的方式进行实现，具体而言就是fork出的进程作为new_task，exec请求的资源作为data，然后用new_task执行exec访问data。

## 实验结果

通过CI

## 问答作业

1. **fork + exec 的一个比较大的问题是 fork 之后的内存页/文件等资源完全没有使用就废弃了，针对这一点，有什么改进策略？**

可以使用COW技术，即当fork的时候先不申请相应空间，等到应用程序执行到相应位置时进行空间（代码、数据）申请，这样就不会出现大量没有使用而废弃的空间。

2. **其实使用了题(1)的策略之后，fork + exec 所带来的无效资源的问题已经基本被解决了，但是今年来 fork 还是在被不断的批判，那么到底是什么正在”杀死”fork？可以参考 [论文](https://www.microsoft.com/en-us/research/uploads/prod/2019/04/fork-hotos19.pdf) ，注意：回答无明显错误就给满分，出这题只是想引发大家的思考，完全不要求看论文，球球了，别卷了。**

- 文件系统压力：由于子进程和父进程只有返回值的区别，那么在复制的时候被父进程打开的文件资源也会被子进程继承，这样整体的文件系统压力会陡然上升。另外，如果没有这样的继承，子进程访问父进程的资源需要重新申请，效率上有问题。
- fork不保证堆内存访问的安全：因为资源的复制，父进程持有的某一临界区的锁也会被子进程获得，这样在临界区访问很容易出现死锁问题
- fork得到的所有进程都在同一个核上，不易于多核扩展

3. **fork 当年被设计并称道肯定是有其好处的。请使用 带初始参数 的 spawn 重写如下 fork 程序，然后描述 fork 有那些好处。注意:使用”伪代码”传达意思即可，spawn 接口可以自定义。可以写多个文件。**

```rust
fn main() {
    let a = get_a();
    if fork() == 0 {
        let b = get_b();
        println!("a + b = {}", a + b);
        exit(0);
    }
    println!("a = {}", a);
    0
}
```

修改后的代码：

```rust
// child.rs
fn main(a: usize) {
	let b = get_b();
	println!("a + b = {}", a + b)
	exit(0)
}

//main.rs
fn main() {
	let a = get_a();
	spawn("child.rs", a);
	println!("a = {}", a);
}
```

`fork`的好处：fork前申明的变量在fork后仍然可以继续使用，而不需要重新申明。如果是spawn=fork+exec的话，fork的变量传给子进程传递的时候，只能通过函数传参，函数传参的空间消耗很大；fork就没有这个问题，空间友好，开销代价小。

4. **描述进程执行的几种状态，以及 `fork/exec/wait/exit` 对于状态的影响。**

进程状态：创建、就绪、等待、运行、退出`Exited`（僵尸`Zombie`）

`fork`创建出的新子进程会处于`就绪`状态

调用`wait`方法后，进程从`运行`切换到`等待`状态

调用`exec`，不改变进程的状态

调用`exit`方法后，进程从`运行`切换到`退出/僵尸`状态